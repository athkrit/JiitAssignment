package t.mk.three.jiitassignment.feature.main.viewModelimport android.os.Parcelableimport androidx.lifecycle.SavedStateHandleimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport kotlinx.coroutines.Jobimport kotlinx.coroutines.flow.SharingStartedimport kotlinx.coroutines.flow.StateFlowimport kotlinx.coroutines.flow.combineimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.flow.stateInimport kotlinx.coroutines.isActiveimport kotlinx.coroutines.launchimport kotlinx.parcelize.Parcelizeimport t.mk.three.jiitassignment.data.RankingApolloClientimport t.mk.three.jiitassignment.extension.proxyimport t.mk.three.jiitassignment.extension.proxyIntimport t.mk.three.jiitassignment.extension.proxyListimport t.mk.three.jiitassignment.feature.main.adapter.MainAdapterimport t.mk.three.jiitassignment.feature.main.repository.BaseMainRepositoryimport kotlin.math.ceilimport kotlin.math.maxprivate const val FILTER_SAVED_STATE_ID = "FILTER_SAVED_STATE_ID"private const val SECTOR_SAVED_STATE_ID = "SECTOR_SAVED_STATE_ID"private const val PAGE_COUNT_SAVED_STATE_ID = "PAGE_COUNT_SAVED_STATE_ID"private const val CURRENT_PAGE_SAVED_STATE_ID = "CURRENT_PAGE_SAVED_STATE_ID"private const val STOCKS_SAVED_STATE_ID = "STOCKS_SAVED_STATE_ID"private const val STATE_SAVED_STATE_ID = "STATE_SAVED_STATE_ID"private const val SECTORS_SAVED_STATE_ID = "SECTORS_SAVED_STATE_ID"private val INITIAL_MARKET = MainViewModel.Filter.THprivate const val PAGE_LIMIT = 30class MainViewModel(    private val repository: BaseMainRepository,    private val savedStateHandle: SavedStateHandle) : ViewModel() {    private val selectedMarketOrdinal =        savedStateHandle.proxyInt(FILTER_SAVED_STATE_ID, INITIAL_MARKET.ordinal)    private val _selectedSector = savedStateHandle.proxy<Sector>(SECTOR_SAVED_STATE_ID, Sector.All)    private val pageCount = savedStateHandle.proxyInt(PAGE_COUNT_SAVED_STATE_ID, 0)    private val currentPage = savedStateHandle.proxyInt(CURRENT_PAGE_SAVED_STATE_ID, 0)    private val stocks = savedStateHandle.proxyList<Stock>(STOCKS_SAVED_STATE_ID, emptyList())    private val state = savedStateHandle.proxy<State>(STATE_SAVED_STATE_ID, State.Initialize)    private val _sectors =        savedStateHandle.proxyList<Sector>(SECTORS_SAVED_STATE_ID, listOf(Sector.All))    val market = selectedMarketOrdinal.getStateFlow()    val sectors = _sectors.getStateFlow()    private val selectedMarket get() = MainViewModel.Filter.entries[selectedMarketOrdinal.value]    val selectedSector = _selectedSector.getStateFlow().map { sector ->        _sectors.value.indexOfFirst { sector == it }    }    val items: StateFlow<List<MainAdapter.Item>> = combine(        stocks.getStateFlow(),        state.getStateFlow()    ) { stocks, state ->        val items = mutableListOf<MainAdapter.Item>()        items.addAll(            stocks.map {                MainAdapter.Item.StockInfo(                    it                )            }        )        when (state) {            is State.InitializeFailed -> {                items.add(                    MainAdapter.Item.FAIL(state.message)                )            }            State.Initialize,            State.LoadMore -> {                items.add(                    MainAdapter.Item.LOADING                )            }            State.Idle,            null -> {                //Do nothing            }        }        items    }.stateIn(        scope = viewModelScope,        started = SharingStarted.WhileSubscribed(5000),        initialValue = emptyList()    )    val canPullToRefresh = state.getStateFlow().map {        it?.canReload ?: false    }    fun init() {        initInternal(            filter = selectedMarket,            sector = _selectedSector.value        )    }    fun setMarket(filter: Filter) {        if (filter != selectedMarket) {            initInternal(                filter = filter,                sector = Sector.All            )        }    }    fun updateSector(sector: Sector) {        if (sector != _selectedSector.value) {            initInternal(                sector = sector            )        }    }    fun reload() {        initInternal()    }    private var initializeJob: Job? = null    private fun initInternal(        filter: Filter = selectedMarket,        sector: Sector = _selectedSector.value    ) {        clearJob()        initializeJob = viewModelScope.launch {            selectedMarketOrdinal.value = filter.ordinal            _selectedSector.value = sector            state.value = State.Initialize            pageCount.value = 0            currentPage.value = 0            stocks.value = emptyList()            val response = repository.getRankingStock(                isLoadSector = true,                market = filter.name,                page = 0,                limit = PAGE_LIMIT,                sectors = listOfNotNull(_selectedSector.value.id)            )            if (isActive) {                when (response) {                    is RankingApolloClient.Result.Error -> {                        pageCount.value = 0                        stocks.value = emptyList()                        state.value = State.InitializeFailed(                            response.error                        )                    }                    is RankingApolloClient.Result.Success -> {                        response.response.jittaRanking?.let { data ->                            _sectors.value = buildList {                                add(                                    Sector.All                                )                                addAll(                                    response.response.listJittaSectorType?.mapNotNull {                                        Sector.Type(                                            id = it?.id ?: "",                                            typeName = it?.name ?: ""                                        )                                    } ?: emptyList()                                )                            }                            pageCount.value =                                max(ceil((data.count ?: 0) / PAGE_LIMIT.toDouble()).toInt() - 1, 0)                            stocks.value = data.data?.map { stock ->                                Stock(                                    id = stock?.id,                                    title = stock?.title,                                    symbol = stock?.symbol,                                    exchange = stock?.exchange,                                    rank = stock?.rank,                                    count = data.count ?: 0,                                    latestPrice = stock?.latestPrice                                )                            } ?: emptyList()                            state.value = State.Idle                            currentPage.value = 0                        } ?: run {                            pageCount.value = 0                            currentPage.value = 0                            stocks.value = emptyList()                            state.value = State.InitializeFailed(                                "stock not found"                            )                        }                    }                }            }        }    }    private var loadMoreJob: Job? = null    fun loadMore() {        val nextPage = currentPage.value + 1        if (            (loadMoreJob?.isCompleted == true || loadMoreJob == null) &&            nextPage <= pageCount.value &&            state.value.canLoadMore        ) {            loadMoreJob = viewModelScope.launch {                state.value = State.LoadMore                val response = repository.getRankingStock(                    market = selectedMarket.name,                    page = nextPage,                    limit = PAGE_LIMIT,                    sectors = listOfNotNull(_selectedSector.value.id)                )                if (isActive) {                    when (response) {                        is RankingApolloClient.Result.Error -> {                            state.value = State.Idle                        }                        is RankingApolloClient.Result.Success -> {                            response.response.jittaRanking?.let { data ->                                currentPage.value = nextPage                                stocks.value = buildList {                                    addAll(stocks.value)                                    addAll(                                        data.data?.map { stock ->                                            Stock(                                                id = stock?.id,                                                title = stock?.title,                                                symbol = stock?.symbol,                                                exchange = stock?.exchange,                                                rank = stock?.rank,                                                count = data.count ?: 0,                                                latestPrice = stock?.latestPrice                                            )                                        } ?: emptyList()                                    )                                }                            }                            state.value = State.Idle                        }                    }                }            }        }    }    private fun clearJob() {        loadMoreJob?.cancel()        initializeJob?.cancel()    }    @Parcelize    sealed class Sector(val name: String, open val id: String?) : Parcelable {        data object All : Sector("All", null)        data class Type(            override val id: String,            val typeName: String        ) : Sector(typeName, id)    }    @Parcelize    sealed class State(val canLoadMore: Boolean, val canReload: Boolean) : Parcelable {        data object Initialize : State(false, false)        data class InitializeFailed(            val message: String        ) : State(false, true)        data object Idle : State(true, true)        data object LoadMore : State(false, true)    }    @Parcelize    data class Stock(        val id: String?,        val title: String?,        val symbol: String?,        val exchange: String?,        val rank: Int?,        val count: Int,        val latestPrice: Double?    ) : Parcelable {        @Parcelize        data class Sector(            val name: String?,        ) : Parcelable    }    enum class Filter(val marketName: String) {        AU("Australia"),        BD("Bangladesh"),        BR("Brazil"),        CA("Canada"),        CN("China"),        DK("Denmark"),        FR("France"),        DE("Germany"),        HK("Hong Kong"),        ID("Indonesia"),        IL("Israel"),        IT("Italy"),        IN("India"),        JP("Japan"),        MY("Malaysia"),        NL("Netherlands"),        PH("philippines"),        SG("Singapore"),        KR("South Korea"),        ES("Spain"),        SE("Sweden"),        CH("Switzerland"),        TW("Taiwan"),        TH("Thailand"),        UAE("United Arab Emirates "),        UK("United Kingdom"),        US("United States"),        VN("Vietnam");        fun getDropdownName(): String {            return "${getFlag(this.name)} ${this.marketName}"        }        private fun getFlag(            region: String        ): String {            val firstLetter = Character.codePointAt(region, 0) - 0x41 + 0x1F1E6            val secondLetter = Character.codePointAt(region, 1) - 0x41 + 0x1F1E6            return String(Character.toChars(firstLetter)) + String(Character.toChars(secondLetter))        }    }}